% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gr.R
\name{gr}
\alias{gr}
\title{gradient of penalizing function for combined parameter estimate}
\usage{
gr(beta, raw_spline, m, lambda, split, A, prop, dim, res, inside, normalize)
}
\arguments{
\item{beta}{vector of parameters of the optimization function}

\item{raw_spline}{auxiliary spline spanning the whole wintering area}

\item{m}{vector of continuous migratory connectivity estimates}

\item{lambda}{weights for different penalization terms}

\item{split}{vector of length of y which defines the affiliation to a
discrete wintering area}

\item{A}{matrix of second derivative of smoothing}

\item{prop}{vector of proportions of individuals going to discrete wintering
areas (discrete estimate or expected value for migratory
connectivity)}

\item{dim}{numeric, spatial dimension}

\item{res}{numeric, spatial resolution}

\item{inside}{specifies if a cell of the gridded window is inside the window
of the data or not. Vector of logicals.}

\item{normalize}{numeric, normalizes the discretized integralt. Equals to the
spatial resolution in one-dimensional space and to the
product of the spatial resolutions in two-dimensional space.}
}
\value{
function depending on bspline parameters, which returns the sum of
        quadratic distances to continuous and discrete migratory connectivity
        and smoothness
}
\description{
This function defines the penalization term for the combined estimation
approach.
It can be used to jointly optimize distance to continuous migratory
connectivity estimates gained by estM, discrete migratory connectivity
estimates and maximize smoothness.
}
\examples{
{
    y <- seq(0, 1, length.out=100)
    i_k <- seq(0.1111111, 0.8888889, length.out = 8)
    r_s <- init_spline(y = y,
        knots = i_k,
        degree = 3,
        intercept = TRUE,
        dim = 1)
     gr <- gr(beta,
         raw_spline = r_s,
         m = mro1D_increasing$mro$estimates$m$all,
         lambda  = c(.05, 300),
         split = mro1D_increasing$split,
         A = splines2::dbs(y, knots=i_k, derivs = 2, degree = 3,
                           intercept = TRUE),
         prop = mro1D_increasing$mro$origins$all$m_discrete /
             sum(mro1D_increasing$mro$origins$all$m_discrete),
         dim = 1,
         res = 100,
         inside = matrix(rep(TRUE, 100 * 100), ncol = 100),
         normalize = 100)
     gr(rnorm(12))
}
}
