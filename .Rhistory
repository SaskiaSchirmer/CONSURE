}
new_breedingArea(1000,w,function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)})
new_winteringArea <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(list(window = window,survival = survival, recovery = recovery), class = "winteringArea")
}
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range of wintering area")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
return(new_winteringArea(window,survival,recovery))
})
}
new_breedingArea <- function(markedInds = numeric(),
# winteringArea,
migratoryConnectivity){
stopifnot(markedInds%%1==0)
stopifnot(class(winteringArea) == "winteringArea")
stopifnot(is.function(migratoryConnectivity))
structure(list(markedInds = markedInds, migratoryConnectivity = migratoryConnectivity), class = "breedingArea")
}
new_breedingArea(1000,w,function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)})
breedingArea <- function(markedInds,migratoryConnectivity){
new_breedingArea(markedInds,migratoryConnectivity)
}
new_observationCircumstances <- function(numberOfBreedingAreas = numeric(),
observationTime = numeric(),
breedingAreas = list(),
winteringArea = winteringArea()){
stopifnot(numberOfBreedingAreas%%1==0)
stopifnot(observationTime%%1==0)
stopifnot(is.list(breedingAreas))
stopifnot(class(winteringArea) == "winteringArea")
structure(list(B = numberOfBreedingAreas,
T = observationTime,
breedingAreas = breedingAreas,
winteringArea = winteringArea))
}
new_winteringArea <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(list(window = window,survival = survival, recovery = recovery), class = "winteringArea")
}
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range of wintering area")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
return(new_winteringArea(window,survival,recovery))
})
}
new_breedingArea <- function(markedInds = numeric(),
# winteringArea,
migratoryConnectivity){
stopifnot(markedInds%%1==0)
stopifnot(class(winteringArea) == "winteringArea")
stopifnot(is.function(migratoryConnectivity))
structure(list(markedInds = markedInds, migratoryConnectivity = migratoryConnectivity), class = "breedingArea")
}
breedingArea <- function(markedInds,migratoryConnectivity){
new_breedingArea(markedInds,migratoryConnectivity)
}
new_observationCircumstances <- function(numberOfBreedingAreas = numeric(),
observationTime = numeric(),
breedingAreas = list(),
winteringArea = winteringArea()){
stopifnot(numberOfBreedingAreas%%1==0)
stopifnot(observationTime%%1==0)
stopifnot(is.list(breedingAreas))
stopifnot(class(winteringArea) == "winteringArea")
structure(list(B = numberOfBreedingAreas,
T = observationTime,
breedingAreas = breedingAreas,
winteringArea = winteringArea))
}
observationCircumstances <- function(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea){
new_observationCircumstances(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea)
}
new_markRecaptureSetting <- function(window = NULL, xrange = c(0,0), yrange = c(0,0),
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime
){
numberOfBreedingAreas <- length(markedInds)
winteringArea <- winteringArea(window,survival,recovery,xrange,yrange)
breedingAreas <- list()
for(b in 1:numberOfBreedingAreas){
breedingAreas[[b]] <- breedingArea(markedInds = markedInds[b],migratoryConnectivity)
}
observationCircumstances <- observationCircumstances(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea)
structure(list(winteringArea = winteringArea, breedingAreas = breedingAreas,
observationCircumstances = observationCircumstances), class = "markRecaptureSetting")
}
markRecaptureSetting <- function(boundary,
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime){
new_markRecaptureSetting(boundary,
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime)
}
obj <- markRecaptureSetting(c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, c(1000,500,10),function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},10)
obj$winteringArea
obj <- markRecaptureSetting(xrange = c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, c(1000,500,10),function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},10)
new_markRecaptureSetting <- function(window = NULL, xrange = c(0,0), yrange = c(0,0),
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime
){
numberOfBreedingAreas <- length(markedInds)
winteringArea <- winteringArea(window,survival,recovery,xrange,yrange)
breedingAreas <- list()
for(b in 1:numberOfBreedingAreas){
breedingAreas[[b]] <- breedingArea(markedInds = markedInds[b],migratoryConnectivity)
}
observationCircumstances <- observationCircumstances(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea)
structure(list(winteringArea = winteringArea, breedingAreas = breedingAreas,
observationCircumstances = observationCircumstances), class = "markRecaptureSetting")
}
markRecaptureSetting <- function(window = NULL, xrange = c(0,0), yrange = c(0,0),
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime){
new_markRecaptureSetting(window,xrange,yrange,
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime)
}
obj <- markRecaptureSetting(xrange = c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, c(1000,500,10),function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},10)
#' constructor for wintering area (1 spatial dimension)
#'
#' This function defines the properties of the wintering area.
#' @param w decimal number: spatial point of recovery (1-dimensional)
#' @param t integer: temporal component of recovery
#' @param b integer: breeding area
#' @param s function: survival function defined over whole wintering area, independent of breeding area
#' @param m function: migratory connectivity definded for all breeding areas and over whole wintering area
#' @param r constant: recovery probability, has to be constant over whole wintering area
#' and independent of breeding area
#' @param T integer: length of observation period
#' @return subdensity of recovered individuals for the specified parameters
#' @export
#' @examples f_f_sub()
new_winteringArea <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(list(window = window,survival = survival, recovery = recovery), class = "winteringArea")
}
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range of wintering area")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
return(new_winteringArea(window,survival,recovery))
})
}
new_breedingArea <- function(markedInds = numeric(),
# winteringArea,
migratoryConnectivity){
stopifnot(markedInds%%1==0)
stopifnot(is.function(migratoryConnectivity))
structure(list(markedInds = markedInds, migratoryConnectivity = migratoryConnectivity), class = "breedingArea")
}
breedingArea <- function(markedInds,migratoryConnectivity){
new_breedingArea(markedInds,migratoryConnectivity)
}
new_observationCircumstances <- function(numberOfBreedingAreas = numeric(),
observationTime = numeric(),
breedingAreas = list(),
winteringArea = winteringArea()){
stopifnot(numberOfBreedingAreas%%1==0)
stopifnot(observationTime%%1==0)
stopifnot(is.list(breedingAreas))
stopifnot(class(winteringArea) == "winteringArea")
structure(list(B = numberOfBreedingAreas,
T = observationTime,
breedingAreas = breedingAreas,
winteringArea = winteringArea))
}
observationCircumstances <- function(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea){
new_observationCircumstances(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea)
}
new_markRecaptureSetting <- function(window = NULL, xrange = c(0,0), yrange = c(0,0),
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime
){
numberOfBreedingAreas <- length(markedInds)
winteringArea <- winteringArea(window,survival,recovery,xrange,yrange)
breedingAreas <- list()
for(b in 1:numberOfBreedingAreas){
breedingAreas[[b]] <- breedingArea(markedInds = markedInds[b],migratoryConnectivity)
}
observationCircumstances <- observationCircumstances(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea)
structure(list(winteringArea = winteringArea, breedingAreas = breedingAreas,
observationCircumstances = observationCircumstances), class = "markRecaptureSetting")
}
markRecaptureSetting <- function(window = NULL, xrange = c(0,0), yrange = c(0,0),
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime){
new_markRecaptureSetting(window,xrange,yrange,
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime)
}
obj <- markRecaptureSetting(xrange = c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, c(1000,500,10),function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},10)
obj$winteringArea
obj <- markRecaptureSetting(xrange = c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, markedInds = c(1000,500,10),migratoryConnectivity = function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},10)
obj <- markRecaptureSetting(xrange = c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, markedInds = c(1000,500,10),migratoryConnectivity = function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},
observationTime= 10)
obj$winteringArea
obj$breedingAreas
?purrr::partial
my_list <- purr::partial(list, 1, 2)
my_list("foo")
my_list <- purrr::partial(list, 1, 2)
my_list("foo")
purrr::partial(f, b= 1)
f
f2 <- purrr::partial(f, b= 1)
f2
curve(f)
curve(f, b = 1)
curve(f(1,x), b = 1)
curve(f(1,x))
curve(f(1,x))
curve(f2(x))
log(0)
# Load packages
library(jagsUI)
ss.sim <- function(sigma.proc = 5, sigma.obs = 10, T = 100, n1 = 0){
true <- observed <- numeric()
true[1] <- n1
for (i in 1:(T-1)){
true[i+1] <- rnorm(1, true[i], sigma.proc)
}
for (i in 1:T){
observed[i] <- rnorm(1, true[i], sigma.obs)
}
plot(true, type = "l", ylim = range(c(true, observed)), xlab = "Time", ylab = "x", las = 1)
lines(observed, col = "red")
return(list(observed = observed, true = true))
}
z <- ss.sim(sigma.proc = 7, sigma.obs = 10, T = 50)
# Specify model in BUGS language
sink("ssm.jags")
cat("
model {
# Priors and constraints
x[1] ~ dnorm(0, 0.01)            # Prior for initial population size
sigma1 ~ dunif(0, 100)           # Prior for sd of state process
tau1 <- pow(sigma1, -2)
sigma2 ~ dunif(0, 500)           # Prior for sd of observation process
tau2 <- pow(sigma2, -2)
# Likelihood
# State process
for (t in 1:(T-1)){
x[t+1] ~ dnorm(x[t], tau1)
}
# Observation process
for (t in 1:T) {
y[t] ~ dnorm(x[t], tau2)
}
}
",fill = TRUE)
sink()
# Bundle data
jags.data <- list(y = z$observed, T = length(z$observed))
# Initial values
inits <- function(){list(sigma1 = runif(1, 0, 5))}
# Parameters monitored
parameters <- c("x", "sigma1", "sigma2")
# MCMC settings
ni <- 5000
nt <- 3
nb <- 1000
nc <- 3
# Call JAGS from R (BRT <1 min)
ssm <- jags(jags.data, inits, parameters, "ssm.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel = TRUE)
ssm
str(sim)
str(ssm)
1.15*0.03
1.15*1.03
1.20*5*4000
(1.15+1.15+1.18+1.18+1.21)*4000
1.18*1,03
1.18*1.03
(1.15+1.15+1.18+1.18+1.22)*4000
1.19*1.03
(1.15+1.15+1.19+1.19+1.23)*4000
(1.15+1.18+1.21+1.19+1.23)*4000
(1.15+1.18+1.21+1.21+1.23)*4000
1.10*1.03
1.10*1.03^2
1.10*1.03^(0:4)
1.10*1.03^(0:4)*4000
sum(1.10*1.03^(0:4)*4000)
sum(1.13*1.03^(0:4)*4000)
sum(1.13*1.03^(c(1,1,2,2,3))*4000)
1.03^(c(1,1,2,2,3))
sum(1.15*1.03^(c(1,1,2,2,3))*4000)
sum(1.13*1.03^(c(1,1,2,2,3))*4000)
sum(1.15*1.03^(c(0,0,1,1,2))*4000)
sum(1.16*1.03^(c(0,0,1,1,2))*4000)
sum(1.18*1.03^(c(0,0,1,1,2))*4000)
sum(1.17*1.03^(c(0,0,1,1,2))*4000)
1.17*1.03^(c(0,0,1,1,2))
1.16*1.03^(c(0,0,1,1,2))
1.16*1.03^(c(0,0,1,1,2,2,3,3))
1.16*1.03^(c(0,0,1,1,2,2,3,3,4))
1.17*1.03^(c(0,0,1,1,2,2,3,3,4))
sum(floor(1.17*1.03^(c(0,0,1,1,2))*4000))
sum(floor(1.16*1.03^(c(0,0,1,1,2))*4000))
floor(1.16*1.03^(c(0,0,1,1,2)))
?floor
floor(1.16*1.03^(c(0,0,1,1,2))*10)
floor(1.16*1.03^(c(0,0,1,1,2))*100)
(1.16*1.03^(c(0,0,1,1,2))*100)
sum(c(1.16+1.16+1.19+1.19+1.23)*4000)
(1.17*1.03^(c(0,0,1,1,2)))
sum(c(1.17+1.17+1.21+1.21+1.24)*4000)
sum(c(1.17+1.17+1.2+1.2+1.24)*4000)
(1.15*1.03^(c(0,0,1,1,2)))
sum(c(1.15+1.15+1.18+1.18+1.22)*4000)
### PhD Saskia Schirmer
### Survival and migratory connectivity
### simulate continuous data and estimate parameters
library(plotly)
B <- 5       # number of breeding areas
f_mean <- seq(0,1,length.out = B) # preparation to get different distributions per breeding area
n <- 1000000    # number of marked individuals in 1 breeding area
T <- 10         # observation time
##############################################
### Second scenario: continuous in 2 dimension
##############################################
### assume that wintering area W is the interval [0,1]
library(tmvtnorm)
### the breeding area specific distribution of individuals
### in the wintering area is a truncated normal as integral over W is 1
f <- function(b,w,lb,ub){
dtmvnorm(w, mean = rep(f_mean[b],2), sigma = diag(0.3,2), lower = rep(lb,2), upper = rep(ub,2))
}
### s is a linear function in w
s <- function(w){-sum(0.25*w)+1}
### r is a constant (for identifiability reasons)
r <- 0.01
# plot true state
# grid functions
fgrid <- function(x, y, f, lb,ub){ # distribution f
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- f(1,c(x[m], y[n]), lb, ub)
}
}
z
}
sgrid <- function(x, y, f){ # survival s
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- s(c(x[m], y[n]))
}
}
z
}
s2grid <- function(x, y, f){ # mortality over all time steps
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- (1-s(c(x[m], y[n])^T))
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=fgrid(x, y, f, 0,1)
ds <- sgrid(x,y,s)
install.packages(c("cubature", "tmvtnorm"))
### PhD Saskia Schirmer
### Survival and migratory connectivity
### simulate continuous data and estimate parameters
library(plotly)
B <- 5       # number of breeding areas
f_mean <- seq(0,1,length.out = B) # preparation to get different distributions per breeding area
n <- 1000000    # number of marked individuals in 1 breeding area
T <- 10         # observation time
##############################################
### Second scenario: continuous in 2 dimension
##############################################
### assume that wintering area W is the interval [0,1]
library(tmvtnorm)
### the breeding area specific distribution of individuals
### in the wintering area is a truncated normal as integral over W is 1
f <- function(b,w,lb,ub){
dtmvnorm(w, mean = rep(f_mean[b],2), sigma = diag(0.3,2), lower = rep(lb,2), upper = rep(ub,2))
}
### s is a linear function in w
s <- function(w){-sum(0.25*w)+1}
### r is a constant (for identifiability reasons)
r <- 0.01
# plot true state
# grid functions
fgrid <- function(x, y, f, lb,ub){ # distribution f
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- f(1,c(x[m], y[n]), lb, ub)
}
}
z
}
sgrid <- function(x, y, f){ # survival s
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- s(c(x[m], y[n]))
}
}
z
}
s2grid <- function(x, y, f){ # mortality over all time steps
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- (1-s(c(x[m], y[n])^T))
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=fgrid(x, y, f, 0,1)
ds <- sgrid(x,y,s)
ds2 <- s2grid(x,y,s)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
# density function for not seen individuals (not found or
# theoretically found, but survived observation time)
f_nf <- function(w,b, lb, ub){
((1-r)*(1-s(w)^T)+s(w)^T)*f(b,w, lb, ub)
}
# density function for found individuals
f_f <- function(w,t,b, lb, ub){
f(b,w, lb,ub)*(s(w)^(t-1)*(1-s(w))*r)
}
# not seen
p_nf <- numeric()
#### change: integrate over 2 dimensions
library(cubature)
for(b in 1:B){
p_nf[b] <- adaptIntegrate(f_nf, c(0,0), c(1,1),b=b, 0,1)$integral
}
for(b in 1:B){
p_nf[b] <- adaptIntegrate(f_nf, c(0,0), c(1,0),b=b, 0,1)$integral
}
p_nf
for(b in 1:B){
p_nf[b] <- adaptIntegrate(f_nf, c(0,0), c(1,1),b=b, 0,1)$integral
}
p_nf
?adaptIntegrate
