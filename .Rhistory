(1.15+1.15+1.18+1.18+1.22)*4000
1.19*1.03
(1.15+1.15+1.19+1.19+1.23)*4000
(1.15+1.18+1.21+1.19+1.23)*4000
(1.15+1.18+1.21+1.21+1.23)*4000
1.10*1.03
1.10*1.03^2
1.10*1.03^(0:4)
1.10*1.03^(0:4)*4000
sum(1.10*1.03^(0:4)*4000)
sum(1.13*1.03^(0:4)*4000)
sum(1.13*1.03^(c(1,1,2,2,3))*4000)
1.03^(c(1,1,2,2,3))
sum(1.15*1.03^(c(1,1,2,2,3))*4000)
sum(1.13*1.03^(c(1,1,2,2,3))*4000)
sum(1.15*1.03^(c(0,0,1,1,2))*4000)
sum(1.16*1.03^(c(0,0,1,1,2))*4000)
sum(1.18*1.03^(c(0,0,1,1,2))*4000)
sum(1.17*1.03^(c(0,0,1,1,2))*4000)
1.17*1.03^(c(0,0,1,1,2))
1.16*1.03^(c(0,0,1,1,2))
1.16*1.03^(c(0,0,1,1,2,2,3,3))
1.16*1.03^(c(0,0,1,1,2,2,3,3,4))
1.17*1.03^(c(0,0,1,1,2,2,3,3,4))
sum(floor(1.17*1.03^(c(0,0,1,1,2))*4000))
sum(floor(1.16*1.03^(c(0,0,1,1,2))*4000))
floor(1.16*1.03^(c(0,0,1,1,2)))
?floor
floor(1.16*1.03^(c(0,0,1,1,2))*10)
floor(1.16*1.03^(c(0,0,1,1,2))*100)
(1.16*1.03^(c(0,0,1,1,2))*100)
sum(c(1.16+1.16+1.19+1.19+1.23)*4000)
(1.17*1.03^(c(0,0,1,1,2)))
sum(c(1.17+1.17+1.21+1.21+1.24)*4000)
sum(c(1.17+1.17+1.2+1.2+1.24)*4000)
(1.15*1.03^(c(0,0,1,1,2)))
sum(c(1.15+1.15+1.18+1.18+1.22)*4000)
### PhD Saskia Schirmer
### Survival and migratory connectivity
### simulate continuous data and estimate parameters
library(plotly)
B <- 5       # number of breeding areas
f_mean <- seq(0,1,length.out = B) # preparation to get different distributions per breeding area
n <- 1000000    # number of marked individuals in 1 breeding area
T <- 10         # observation time
##############################################
### Second scenario: continuous in 2 dimension
##############################################
### assume that wintering area W is the interval [0,1]
library(tmvtnorm)
### the breeding area specific distribution of individuals
### in the wintering area is a truncated normal as integral over W is 1
f <- function(b,w,lb,ub){
dtmvnorm(w, mean = rep(f_mean[b],2), sigma = diag(0.3,2), lower = rep(lb,2), upper = rep(ub,2))
}
### s is a linear function in w
s <- function(w){-sum(0.25*w)+1}
### r is a constant (for identifiability reasons)
r <- 0.01
# plot true state
# grid functions
fgrid <- function(x, y, f, lb,ub){ # distribution f
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- f(1,c(x[m], y[n]), lb, ub)
}
}
z
}
sgrid <- function(x, y, f){ # survival s
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- s(c(x[m], y[n]))
}
}
z
}
s2grid <- function(x, y, f){ # mortality over all time steps
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- (1-s(c(x[m], y[n])^T))
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=fgrid(x, y, f, 0,1)
ds <- sgrid(x,y,s)
install.packages(c("cubature", "tmvtnorm"))
### PhD Saskia Schirmer
### Survival and migratory connectivity
### simulate continuous data and estimate parameters
library(plotly)
B <- 5       # number of breeding areas
f_mean <- seq(0,1,length.out = B) # preparation to get different distributions per breeding area
n <- 1000000    # number of marked individuals in 1 breeding area
T <- 10         # observation time
##############################################
### Second scenario: continuous in 2 dimension
##############################################
### assume that wintering area W is the interval [0,1]
library(tmvtnorm)
### the breeding area specific distribution of individuals
### in the wintering area is a truncated normal as integral over W is 1
f <- function(b,w,lb,ub){
dtmvnorm(w, mean = rep(f_mean[b],2), sigma = diag(0.3,2), lower = rep(lb,2), upper = rep(ub,2))
}
### s is a linear function in w
s <- function(w){-sum(0.25*w)+1}
### r is a constant (for identifiability reasons)
r <- 0.01
# plot true state
# grid functions
fgrid <- function(x, y, f, lb,ub){ # distribution f
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- f(1,c(x[m], y[n]), lb, ub)
}
}
z
}
sgrid <- function(x, y, f){ # survival s
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- s(c(x[m], y[n]))
}
}
z
}
s2grid <- function(x, y, f){ # mortality over all time steps
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- (1-s(c(x[m], y[n])^T))
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=fgrid(x, y, f, 0,1)
ds <- sgrid(x,y,s)
ds2 <- s2grid(x,y,s)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
# density function for not seen individuals (not found or
# theoretically found, but survived observation time)
f_nf <- function(w,b, lb, ub){
((1-r)*(1-s(w)^T)+s(w)^T)*f(b,w, lb, ub)
}
# density function for found individuals
f_f <- function(w,t,b, lb, ub){
f(b,w, lb,ub)*(s(w)^(t-1)*(1-s(w))*r)
}
# not seen
p_nf <- numeric()
#### change: integrate over 2 dimensions
library(cubature)
for(b in 1:B){
p_nf[b] <- adaptIntegrate(f_nf, c(0,0), c(1,1),b=b, 0,1)$integral
}
for(b in 1:B){
p_nf[b] <- adaptIntegrate(f_nf, c(0,0), c(1,0),b=b, 0,1)$integral
}
p_nf
for(b in 1:B){
p_nf[b] <- adaptIntegrate(f_nf, c(0,0), c(1,1),b=b, 0,1)$integral
}
p_nf
?adaptIntegrate
wd <- getwd()
setwd("..")
devtools::install("continuousSpatioTemporalMarkRecapture/")
library(continousSpatioTemporalMarkRecapture)
B <- 5     # number of breeding areas
res_x <- 100
mro <- markRecaptureObject(xrange = c(0,1),
survival = function(w){0.5*w+.4},
recovery = function(w){0.01},
markedInds = ceiling(runif(B,100000,1000000)) ,
migratoryConnectivity = function(b,w){
truncnorm::dtruncnorm(w,0,1, mean = seq(0.1,0.9,length.out = B)[b], sd = 0.3)},
observationTime = 10)
out <- simContin(mro)
eta <- out$eta
k <- out$k
res_x <- 100
kde_all <- estKDE(eta, mro$numberOfBreedingAreas,mro$observationTime,res_x, all = TRUE)
kde <- estKDE(eta,mro$numberOfBreedingAreas,mro$observationTime,res_x)
plotFsr(f,s,r,T)
plotFsr1D(f,s,r,T)
## todo
plotFsr1D(mro)
mro$breedingAreas[[1]]
f_f
setwd(wd)
devtools::document
devtools::document()
devtools::document()
wd <- getwd()
setwd("..")
devtools::install("continuousSpatioTemporalMarkRecapture/")
library(continousSpatioTemporalMarkRecapture)
B <- 5     # number of breeding areas
res_x <- 100
mro <- markRecaptureObject(xrange = c(0,1),
survival = function(w){0.5*w+.4},
recovery = function(w){0.01},
markedInds = ceiling(runif(B,100000,1000000)) ,
migratoryConnectivity = function(b,w){
truncnorm::dtruncnorm(w,0,1, mean = seq(0.1,0.9,length.out = B)[b], sd = 0.3)},
observationTime = 10)
plotFsr1D(mro)
out <- simContin(mro)
eta <- out$eta
k <- out$k
res_x <- 100
kde_all <- estKDE(eta, mro$numberOfBreedingAreas,mro$observationTime,res_x, all = TRUE)
kde <- estKDE(eta,mro$numberOfBreedingAreas,mro$observationTime,res_x)
out <- simContin(mro)
eta <- out$eta
k <- out$k
res_x <- 100
kde_all <- estKDE(eta, mro$numberOfBreedingAreas,mro$observationTime,res_x, all = TRUE)
kde <- estKDE(eta,mro$numberOfBreedingAreas,mro$observationTime,res_x)
#source("plotKDE.R")
plotKDE1D(1,kde_all,res_x,f_f_sub,s,f,r,T)
plotKDE1D()
plotKDE1D(
plotKDE1D
))))))
plotKDE1D
#source("plotKDE.R")
plotKDE1D(1,kde_all,res_x,mro)
for(b in 1:B){
plotKDE1D(b,kde,res_x,mro)
}
legend("topright",c("true","estimate"), lty = c(2,1), col = 1)
B <- 5       # number of breeding areas
f_mean <- seq(0,1,length.out = B) # preparation to get different distributions per breeding area
n <- 1000000    # number of marked individuals in 1 breeding area
T <- 10         # observation time
##############################################
### Second scenario: continuous in 2 dimension
##############################################
### assume that wintering area W is the interval [0,1]
library(tmvtnorm)
### the breeding area specific distribution of individuals
### in the wintering area is a truncated normal as integral over W is 1
f <- function(b,w,lb,ub){
dtmvnorm(w, mean = rep(f_mean[b],2), sigma = diag(0.3,2), lower = rep(lb,2), upper = rep(ub,2))
}
### s is a linear function in w
s <- function(w){-sum(0.25*w)+1}
### r is a constant (for identifiability reasons)
r <- 0.01
# plot true state
# grid functions
fgrid <- function(x, y, f, lb,ub){ # distribution f
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- f(1,c(x[m], y[n]), lb, ub)
}
}
z
}
sgrid <- function(x, y, f){ # survival s
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- s(c(x[m], y[n]))
}
}
z
}
s2grid <- function(x, y, f){ # mortality over all time steps
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- (1-s(c(x[m], y[n])^T))
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=fgrid(x, y, f, 0,1)
ds <- sgrid(x,y,s)
ds2 <- s2grid(x,y,s)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
my_grid <- function(x,y,func,lb=0,ub=1){
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
b <- 1
w <- c(x[m], y[n])
z[m,n] <- f(...)
}
}
z
}
# compute density for grid
d=my_grid(x, y, f, 0,1)
my_grid <- function(x,y,func,lb=0,ub=1){
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
b <- 1
w <- c(x[m], y[n])
z[m,n] <- func(...)
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=my_grid(x, y, f, 0,1)
my_grid <- function(x,y,func,lb=0,ub=1){
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
b <- 1
w <- c(x[m], y[n])
z[m,n] <- func(w,...)
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=my_grid(x, y, f, 0,1)
my_grid <- function(x,y,func,...){
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
b <- 1
w <- c(x[m], y[n])
z[m,n] <- func(w,...)
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=my_grid(x, y, f, 0,1)
# compute density for grid
d=my_grid(x, y, f, ub=0,lb=1,b=1)
# compute density for grid
d=my_grid(x, y, f, lb=0,ub=1,b=1)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
par_grid <- function(x,y,func,...){
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
b <- 1
w <- c(x[m], y[n])
z[m,n] <- func(w,...)
}
}
z
}
ds <- par_grid(x,y,s)
ds2 <- par_grid(x,y,function(s,x) {1-s(x)^T} ,s, T)
ds2 <- par_grid(x,y,function(s,x,T) {1-s(x)^T} ,s, T)
ds2 <- par_grid(x,y,function(s,x,T) {1-s(x)^T} ,s = s, T = 10)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
ds2 <- par_grid(x,y,function(w,s,T) {1-s(x)^T} ,s = s, T = 10)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
ds2 <- par_grid(x,y,function(w,s,T) {1-s(w)^T} ,s = s, T = 10)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
par_grid <- function(x,y,func,...){
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
w <- c(x[m], y[n])
z[m,n] <- func(w,...)
}
}
z
}
s2grid <- function(x, y, f){ # mortality over all time steps
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- (1-s(c(x[m], y[n])^T))
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=par_grid(x, y, f, lb=0,ub=1,b=1)
ds <- par_grid(x,y,s)
ds2 <- par_grid(x,y,function(w,s,T) {1-s(w)^T} ,s = s, T = 10)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
s
ds2 <- s2grid(x,y,f)
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
s2grid <- function(x, y){ # mortality over all time steps
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
z[m,n] <- (1-s(c(x[m], y[n])^T))
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=par_grid(x, y, f, lb=0,ub=1,b=1)
ds <- par_grid(x,y,s)
ds2 <- s2grid(x,y,f)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
s2grid <- function(x, y){ # mortality over all time steps
z <- matrix(nrow=length(x), ncol=length(y))
for(m in 1:length(x)){
for(n in 1:length(y)){
#w <- c(x[m], y[n])
z[m,n] <- (1-s(c(x[m], y[n]))^T)
}
}
z
}
x <- seq(0,1,length.out = 100)
y <- seq(0,1,length.out = 100)
# compute density for grid
d=par_grid(x, y, f, lb=0,ub=1,b=1)
ds <- par_grid(x,y,s)
ds2 <- par_grid(x,y,function(w,s,T) {1-s(w)^T} ,s = s, T = 10)
ds2 <- s2grid(x,y,f)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
ds2 <- s2grid(x,y)
# plot density as contourplot
contour(x, y, d, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]))
contour(x, y, ds, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "red")
contour(x, y, ds2, nlevels=5, main="Truncated Multivariate Normal Density",
xlab=expression(x[1]), ylab=expression(x[2]), add = TRUE, col = "blue")
par_grid(x,1,f)
par_grid(x,1,s)
contour(x,1,par_grid(x,1,s))
lines(x,par_grid(x,1,s))
plotFsr1D(mro)
mro$winteringArea$window$yrange
