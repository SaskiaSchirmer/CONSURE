}
# Define the multinomial likelihood
for (b in 1:B){
marr[b,1:(n.occasions+1)] ~ dmulti(pr[b,], rel[b])
}
# Define the cell probabilities of the m-array
# Main diagonal
for (b in 1:B){
pr[b,1] <- (1-s[1])*r[1]
# Above main diagonal
for (j in 2:n.occasions){
pr[b,j] <- prod(s[1:(j-1)])*(1-s[j])*r[j]
} #j
}
# Last column: probability of non-recovery
for (b in 1:B){
pr[b,n.occasions+1] <- 1-sum(pr[b,1:n.occasions])
} #t
}
",fill = TRUE)
sink()
# Bundle data
jags.data <- list(marr = marr, n.occasions = dim(marr)[2]-1, rel = rowSums(marr),
B = dim(marr)[1])
# Initial values
inits <- function(){list(mean.s = runif(1, 0, 1), mean.r = runif(1, 0, 1))}
# Parameters monitored
parameters <- c("mean.s", "mean.r")
# MCMC settings
ni <- 5000
nt <- 6
nb <- 2000
nc <- 3
# Call JAGS from R (BRT <1 min)
mr <- jags(jags.data, inits, parameters, "mr-mnl.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
# Initial values
inits <- function(){list(mean.s = runif(n.occasions, 0, 1), mean.r = runif(n.occasions, 0, 1))}
# Parameters monitored
parameters <- c("mean.s", "mean.r")
# MCMC settings
ni <- 5000
nt <- 6
nb <- 2000
nc <- 3
# Call JAGS from R (BRT <1 min)
mr <- jags(jags.data, inits, parameters, "mr-mnl.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
# Call JAGS from R (BRT <1 min)
mr <- jags(jags.data, inits=NULL, parameters, "mr-mnl.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
# Summarize posteriors
print(mr, digits = 3)
hist(mr$BUGSoutput$sims.list$mean.s, nclass = 25, col = "gray", main = "", ylab = "Frequency", xlab = "Survival probability")
mr$BUGSoutput$sims.list$mean.s
boxplot(mr$BUGSoutput$sims.list$mean.s)
boxplot(mr$BUGSoutput$sims.list$mean.r)
marr <- tmp3[,2:150]
library(lubridate)
f <- yday(tab$markingDate)
year <- year(tab$markingDate)
sink("mr-mnl.jags")
cat("
model {
# Priors and constraints
for (t in 1:n.occasions){
s[t] <- mean.s[t]
r[t] <- mean.r[t]
}
for(t in 1:n.occasions){
mean.s[t] ~ dunif(0, 1)              # Prior for mean survival
mean.r[t] ~ dunif(0, 1)              # Prior for mean recovery
}
# Define the multinomial likelihood
for (b in 1:B){
marr[b,1:(n.occasions+1)] ~ dmulti(pr[b,], rel[b])
}
# Define the cell probabilities of the m-array
# Main diagonal
for (b in 1:B){
pr[b,1] <- (1-s[1])*r[1]
# Above main diagonal
for (j in 2:n.occasions){
pr[b,j] <- prod(s[1:(j-1)])*(1-s[j])*r[j]
} #j
}
# Last column: probability of non-recovery
for (b in 1:B){
pr[b,n.occasions+1] <- 1-sum(pr[b,1:n.occasions])
} #t
}
",fill = TRUE)
sink()
# Bundle data
jags.data <- list(marr = marr, n.occasions = dim(marr)[2]-1, rel = rowSums(marr),
B = dim(marr)[1])
# Initial values
inits <- function(){list(mean.s = runif(n.occasions, 0, 1), mean.r = runif(n.occasions, 0, 1))}
# Parameters monitored
parameters <- c("mean.s", "mean.r")
# MCMC settings
ni <- 5000
nt <- 6
nb <- 2000
nc <- 3
# Call JAGS from R (BRT <1 min)
mr <- jags(jags.data, inits=NULL, parameters, "mr-mnl.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
# Summarize posteriors
print(mr, digits = 3)
boxplot(mr$BUGSoutput$sims.list$mean.s)
boxplot(mr$BUGSoutput$sims.list$mean.r)
marr <- tmp3[,2:50]
marr[,(ncol(marr)+1)] <- tmp3$numberMarked + rowSums(tmp3[,151:16527])
marr
library(lubridate)
f <- yday(tab$markingDate)
year <- year(tab$markingDate)
sink("mr-mnl.jags")
cat("
model {
# Priors and constraints
for (t in 1:n.occasions){
s[t] <- mean.s[t]
r[t] <- mean.r[t]
}
for(t in 1:n.occasions){
mean.s[t] ~ dunif(0, 1)              # Prior for mean survival
mean.r[t] ~ dunif(0, 1)              # Prior for mean recovery
}
# Define the multinomial likelihood
for (b in 1:B){
marr[b,1:(n.occasions+1)] ~ dmulti(pr[b,], rel[b])
}
# Define the cell probabilities of the m-array
# Main diagonal
for (b in 1:B){
pr[b,1] <- (1-s[1])*r[1]
# Above main diagonal
for (j in 2:n.occasions){
pr[b,j] <- prod(s[1:(j-1)])*(1-s[j])*r[j]
} #j
}
# Last column: probability of non-recovery
for (b in 1:B){
pr[b,n.occasions+1] <- 1-sum(pr[b,1:n.occasions])
} #t
}
",fill = TRUE)
sink()
# Bundle data
jags.data <- list(marr = marr, n.occasions = dim(marr)[2]-1, rel = rowSums(marr),
B = dim(marr)[1])
# Initial values
inits <- function(){list(mean.s = runif(n.occasions, 0, 1), mean.r = runif(n.occasions, 0, 1))}
# Parameters monitored
parameters <- c("mean.s", "mean.r")
# MCMC settings
ni <- 5000
nt <- 6
nb <- 2000
nc <- 3
# Call JAGS from R (BRT <1 min)
mr <- jags(jags.data, inits=NULL, parameters, "mr-mnl.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
# Summarize posteriors
print(mr, digits = 3)
boxplot(mr$BUGSoutput$sims.list$mean.s)
boxplot(mr$BUGSoutput$sims.list$mean.r)
marr <- tmp3[,2:150]
marr[,(ncol(marr)+1)] <- tmp3$numberMarked + rowSums(tmp3[,151:16527])
library(lubridate)
f <- yday(tab$markingDate)
year <- year(tab$markingDate)
sink("mr-mnl.jags")
cat("
model {
# Priors and constraints
for (t in 1:n.occasions){
s[t] <- mean.s[t]
r[t] <- mean.r[t]
}
for(t in 1:n.occasions){
mean.s[t] ~ dunif(0, 1)              # Prior for mean survival
mean.r[t] ~ dunif(0, 1)              # Prior for mean recovery
}
# Define the multinomial likelihood
for (b in 1:B){
marr[b,1:(n.occasions+1)] ~ dmulti(pr[b,], rel[b])
}
# Define the cell probabilities of the m-array
# Main diagonal
for (b in 1:B){
pr[b,1] <- (1-s[1])*r[1]
# Above main diagonal
for (j in 2:n.occasions){
pr[b,j] <- prod(s[1:(j-1)])*(1-s[j])*r[j]
} #j
}
# Last column: probability of non-recovery
for (b in 1:B){
pr[b,n.occasions+1] <- 1-sum(pr[b,1:n.occasions])
} #t
}
",fill = TRUE)
sink()
# Bundle data
jags.data <- list(marr = marr, n.occasions = dim(marr)[2]-1, rel = rowSums(marr),
B = dim(marr)[1])
# Initial values
inits <- function(){list(mean.s = runif(n.occasions, 0, 1), mean.r = runif(n.occasions, 0, 1))}
# Parameters monitored
parameters <- c("mean.s", "mean.r")
# MCMC settings
ni <- 5000
nt <- 6
nb <- 2000
nc <- 3
# Call JAGS from R (BRT <1 min)
mr <- jags(jags.data, inits=NULL, parameters, "mr-mnl.jags",
n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
# Summarize posteriors
print(mr, digits = 3)
boxplot(mr$BUGSoutput$sims.list$mean.s)
boxplot(mr$BUGSoutput$sims.list$mean.r)
cut(tab$ageInDays, seq(1,16540,by = 20))
tmp <- as.data.frame.matrix(table(tab$markArea, cut(tab$ageInDays, seq(1,16540,by = 20))))
tmp$markArea <- row.names(tmp)
tmp
marked <- readr::read_delim("/home/saskia/Dokumente/DokumenteBuero/WiAssSempach/projects/osprey/data/markedPerYear.txt", delim = " ")
tmp2 <- marked %>% group_by(markArea) %>%
summarise(numberMarked = sum(numberMarked))
tmp3 <- merge(tmp, tmp2, by = "markArea", all = FALSE)
tmp3$numberMarked <- tmp3$numberMarked - rowSums(tmp3[,2:16527])
tmp3$numberMarked <- tmp3$numberMarked - rowSums(tmp3[,2:(ncol(tmp3)-1)])
marr <- tmp3[,2:50]
marr[,(ncol(marr)+1)] <- tmp3$numberMarked + rowSums(tmp3[,151:(ncol(tmp3)-1)])
age <- c(rep(1,365), rep(2, 365), rep(3, ncol(marr)-1-2*365))
doy <- rep(rep(1,365), 30)[1:length(age)]
library(lubridate)
f <- yday(tab$markingDate)
year <- year(tab$markingDate)
sink("mr-mnl.jags")
cat("
model {
# Priors and constraints
for (t in 1:n.occasions){
s[t] <- mean.s[t]
r[t] <- mean.r[t]
}
for(t in 1:n.occasions){
mean.s[t] ~ dunif(0, 1)              # Prior for mean survival
mean.r[t] ~ dunif(0, 1)              # Prior for mean recovery
}
# Define the multinomial likelihood
for (b in 1:B){
marr[b,1:(n.occasions+1)] ~ dmulti(pr[b,], rel[b])
}
# Define the cell probabilities of the m-array
# Main diagonal
for (b in 1:B){
pr[b,1] <- (1-s[1])*r[1]
# Above main diagonal
for (j in 2:n.occasions){
pr[b,j] <- prod(s[1:(j-1)])*(1-s[j])*r[j]
} #j
}
# Last column: probability of non-recovery
for (b in 1:B){
pr[b,n.occasions+1] <- 1-sum(pr[b,1:n.occasions])
} #t
}
",fill = TRUE)
sink()
# Bundle data
jags.data <- list(marr = marr, n.occasions = dim(marr)[2]-1, rel = rowSums(marr),
B = dim(marr)[1])
# Initial values
inits <- function(){list(mean.s = runif(n.occasions, 0, 1), mean.r = runif(n.occasions, 0, 1))}
# Parameters monitored
parameters <- c("mean.s", "mean.r")
# MCMC settings
ni <- 5000
nt <- 6
nb <- 2000
nc <- 3
# Call JAGS from R (BRT <1 min)
mr <- jags(jags.data, inits=NULL, parameters, "mr-mnl.jags",
n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
# Summarize posteriors
print(mr, digits = 3)
boxplot(mr$BUGSoutput$sims.list$mean.s)
boxplot(mr$BUGSoutput$sims.list$mean.r)
marr <- tmp3[,2:150]
marr[,(ncol(marr)+1)] <- tmp3$numberMarked + rowSums(tmp3[,151:(ncol(tmp3)-1)])
age <- c(rep(1,365), rep(2, 365), rep(3, ncol(marr)-1-2*365))
doy <- rep(rep(1,365), 30)[1:length(age)]
library(lubridate)
f <- yday(tab$markingDate)
year <- year(tab$markingDate)
sink("mr-mnl.jags")
cat("
model {
# Priors and constraints
for (t in 1:n.occasions){
s[t] <- mean.s[t]
r[t] <- mean.r[t]
}
for(t in 1:n.occasions){
mean.s[t] ~ dunif(0, 1)              # Prior for mean survival
mean.r[t] ~ dunif(0, 1)              # Prior for mean recovery
}
# Define the multinomial likelihood
for (b in 1:B){
marr[b,1:(n.occasions+1)] ~ dmulti(pr[b,], rel[b])
}
# Define the cell probabilities of the m-array
# Main diagonal
for (b in 1:B){
pr[b,1] <- (1-s[1])*r[1]
# Above main diagonal
for (j in 2:n.occasions){
pr[b,j] <- prod(s[1:(j-1)])*(1-s[j])*r[j]
} #j
}
# Last column: probability of non-recovery
for (b in 1:B){
pr[b,n.occasions+1] <- 1-sum(pr[b,1:n.occasions])
} #t
}
",fill = TRUE)
sink()
# Bundle data
jags.data <- list(marr = marr, n.occasions = dim(marr)[2]-1, rel = rowSums(marr),
B = dim(marr)[1])
# Initial values
inits <- function(){list(mean.s = runif(n.occasions, 0, 1), mean.r = runif(n.occasions, 0, 1))}
# Parameters monitored
parameters <- c("mean.s", "mean.r")
# MCMC settings
ni <- 5000
nt <- 6
nb <- 2000
nc <- 3
# Call JAGS from R (BRT <1 min)
mr <- jags(jags.data, inits=NULL, parameters, "mr-mnl.jags",
n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, working.directory = getwd())
# Summarize posteriors
print(mr, digits = 3)
boxplot(mr$BUGSoutput$sims.list$mean.s)
365/20
boxplot(mr$BUGSoutput$sims.list$mean.r)
150/20
load("~/Dokumente/DokumenteBuero/WiAssSempach/RCode/CONSUREcontinuousOnly/mro2_paper.Rdata")
library(CONSURE)
split <- c(rep(rep(1:2, each = 50),50),rep(rep(3:4, each = 50),50))
knots_prop <-list(latitude = seq(0,100222.8,le=3),
longitude = seq(0,123642.5,le=3))
mro2 <- calc_discrete_m(mro2,knots_prop)
mro2 <- calc_discrete_m(mro2,knots_prop)
o_o <- optimization_object(mark_recapture_object = mro2,
y = list(longitude = seq(0,100222.8,le = 100),
latitude = seq(0,123642.5,le=100)),
knots = list(longitude = seq(0,100222.8,le=10),
latitude = seq(0,123642.5,le=10)),
b = "all",
split = split,
lambda = c(.001,10),use_corrected_m = FALSE
)
tmp <- comb_estimate(optimization_object = o_o, maxit = 100000000,start_times =1,reltol = 1e-8, change_r = TRUE)
tmp <- comb_estimate(optimization_object = o_o, maxit = 100000000,start_times =10,reltol = 1e-8, change_r = TRUE)
tmp <- comb_estimate(optimization_object = o_o, maxit = 100000000,start_times =10,reltol = 1e-8, change_r = TRUE)
usethis::use_github_action("check-standard")
usethis::use_github_action("pkgdown")
usethis::use_github_action("lint")
usethis::use_pkgdown()
install.packages("lintr")
install.packages("styler")
styler::style_pkg()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
lintr::lint_package()
library(CONSURE)
knitr::include_graphics("~/vignettes/5comb.png")
knitr::include_graphics("5comb.png")
mtcars.vars = c("mpg", "cyl", "disp")
summary_function <- function(statistic){
for(c in mtcars.vars){
var_mean <- mtcars %>%
group_by(am) %>%
summarise(mean= statistic(c), na.rm = TRUE)
}
}
summary_function(mean)
library(tidyverse)
mtcars.vars = c("mpg", "cyl", "disp")
summary_function <- function(statistic){
for(c in mtcars.vars){
var_mean <- mtcars %>%
group_by(am) %>%
summarise(mean= statistic(c), na.rm = TRUE)
}
}
summary_function(mean)
mtcars
mtcars %>% summarize(across(mtcars.vars, mean), .by = am
)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(CONSURE)
knitr::include_graphics("0comb.png")
knitr::include_graphics("1comb.png")
knitr::include_graphics("2comb.png")
knitr::include_graphics("3comb.png")
knitr::include_graphics("4comb.png")
knitr::include_graphics("5comb.png")
B <- 3
mro <- mark_recapture_object(
xrange = c(0, 1),
survival = function(w) {
stmp <- function(w) 0.5 * w + .4
stmp(w / 100222.8)
},
recovery = function(w) {
rtmp <- function(w) 0.2 * w + 0.01
rtmp(w / 100222.8)
},
migratory_connectivity = function(b, w, B = B) {
mtmp <- function(b, w, B = B) {
truncnorm::dtruncnorm(w, 0, 1,
mean = seq(0.1, 0.9,
length.out = B
)[b],
sd = 0.3
)
}
mtmp(b, w / 100222.8, B)
},
marked_individuals = rep(100000, B),
observation_time = 10, robust = TRUE
)
mro <- sim_contin(mro)
mro <- sim_contin(mro)
mro <- est_parameters(mro, res = 100)
mro <- est_parameters(mro, res = 100)
mro
?devtools
??devtools
library(CONSURE)
is_check <- ("CheckExEnv" %in% search()) || any(c("_R_CHECK_TIMINGS_",
"_R_CHECK_LICENSE_") %in% names(Sys.getenv()))
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
message = FALSE,
warning = FALSE,
eval = !is_check
)
library(CONSURE)
data("robins_init")
str(robins_init, max.level = 2)
colnames(robins_init$recovery_data)
robins_init$recovery_data <- rename_data(
recovery_data = robins_init$recovery_data,
xname = "recLon",
yname = "recLat",
timename = "age",
mark_area_name = "markArea"
)
colnames(robins_init$recovery_data)
rwd <- mark_recapture_object(
window = robins_init$window,
real_recoveries = robins_init$recovery_data,
marked_individuals =
robins_init$mark_area$marked_individuals,
observation_time = robins_init$observation_time,
origin_names = robins_init$mark_area$mark_area
)
plot_raw_recoveries(rwd)
install.packages("spData")
setwd("/home/saskia/Downloads/FINAL_06_09/Rohdaten/Loggerdaten-2012/")
library(lubridate)
library(tidyverse)
zeitstart<-as.POSIXlt("2012-01-01 00:00:01")
tab_a <- read.table(file = "2012-06-12 1a.txt", fill = TRUE)
tab_a <- tab_a[-nrow(tab_a),]
tab_a$date_time <- as.POSIXlt(paste(tab_a[,1], tab_a[,2]),format = "%d.%m.%y %H:%M:%S", tz = "UTC")
tab_a$diff  <- c(0,difftime(tab_a$date_time[2:nrow(tab_a)], tab_a$date_time[1:(nrow(tab_a)-1)], units = "secs"))
tab_i <- read.table(file = "2012-06-12 1i.txt", fill = TRUE)
tab_i <- tab_i[-nrow(tab_i),]
tab_i$date_time <- as.POSIXlt(paste(tab_i[,1], tab_i[,2]),format = "%d.%m.%y %H:%M:%S", tz = "UTC")
tab_i$diff  <- c(0,difftime(tab_i$date_time[2:nrow(tab_i)], tab_i$date_time[1:(nrow(tab_i)-1)], units = "secs"))
plot(tab_a$date_time, tab_a$diff)
points(tab_i$date_time, tab_i$diff)
mean(difftime(tab_a$date_time, tab_i$date_time, units = "secs"))
plot(tab_a$date_time, tab_a$diff)
points(tab_i$date_time-difftime(tab_i$date_time[1],tab_a$date_time[1]) + seconds(2.5), tab_i$diff, col = "red")
tab_i$date_time <- tab_i$date_time-difftime(tab_i$date_time[1],tab_a$date_time[1]) - 1
tab_a <- tab_a %>% filter(V3 == names(which.max(table(tab_i$V3)))) %>% select(date_time) %>% mutate(in_out = "a")
tab_i <- tab_i %>% filter(V3 == names(which.max(table(tab_i$V3)))) %>% select(date_time) %>% mutate(in_out = "i")
tab <- bind_rows(tab_a, tab_i) %>%
arrange(date_time)
tab <- bind_rows(tab_a, tab_i) %>%
mutate(new_i = case_when(in_out == "i" ~ date_time + seconds(30),
in_out == "a" ~ date_time)) %>%
arrange(date_time)
tab <- tab %>% mutate(diff1 = c(0,diff(difftime(new_i, min(date_time), units = "secs"))),
diff2 = c(0,diff(difftime(date_time, min(date_time), units = "secs"))))
plot(tab$date_time, tab$diff1,  col = factor(tab$in_out), ylim = c(-2000,2000))
library(CONSURE)
devtools::load_all(".")
devtools::document()
