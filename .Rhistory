}
new_observationCircumstances <- function(numberOfBreedingAreas = numeric(),
observationTime = numeric(),
breedingAreas = list(),
winteringArea = winteringArea1D()){
stopifnot(numberOfBreedingAreas%%1==0)
stopifnot(observationTime%%1==0)
stopifnot(is.list(breedingAreas))
stopifnot(class(winteringArea) == "winteringArea1D")
structure(list(B = numberOfBreedingAreas,
T = observationTime,
breedingAreas = breedingAreas,
winteringArea = winteringArea))
}
new_breedingArea(1000,w,function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)})
new_breedingArea(1000,1,function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)})
w <- winteringArea1D(win,s,r)
winteringArea1D <- function(window,survival,recovery){
new_winteringArea1D(window,survival,recovery)
}
new_winteringArea1D <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(boundary, class = "winteringArea1D")
}
winteringArea1D <- function(window,survival,recovery){
new_winteringArea1D(window,survival,recovery)
}
w <- winteringArea1D(win,s,r)
B <- 5     # number of breeding areas
#f_mean <- 0.3
f_mean <- seq(0.1,0.9,length.out = B) # preparation to get different distributions per breeding area
f_sd <- 0.3
n <- ceiling(runif(B,100000,1000000))    # number of marked individuals in 1 breeding area
T <- 10         # observation time
res_x <- 100
### the breeding area specific distribution of individuals
### in the wintering area is a truncated normal as integral over W is 1
f <- function(b,w){
truncnorm::dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)}
### s is a linear function in w
s <- function(w){0.5*w+.4}
### r is a constant (for identifiability reasons)
r <- 0.01
w <- winteringArea1D(win,s,r)
### r is a constant (for identifiability reasons)
r <- function(w){0.01}
w <- winteringArea1D(win,s,r)
new_winteringArea1D <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(window, class = "winteringArea1D")
}
winteringArea1D <- function(window,survival,recovery){
new_winteringArea1D(window,survival,recovery)
}
w <- winteringArea1D(win,s,r)
win2 <- as.owin(list(xrange=c(0,1)))
win2 <- as.owin(list(xrange=c(0,1), yrange = c(0,0)))
w <- winteringArea1D(win2,s,r)
plot(win2)
winteringArea1D <- function(window,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
if(!is.owin(window)){as.owin(list(xrange = xrange, yrange = yrange))}
new_winteringArea1D(window,survival,recovery)
}
w <- winteringArea1D(win,s,r)
plot(w)
winteringArea1D(s=s,r=r,xrange = c(0,1))
is.owin(NULL)
winteringArea1D <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
if(!is.owin(window)){as.owin(list(xrange = xrange, yrange = yrange))}
new_winteringArea1D(window,survival,recovery)
}
winteringArea1D(s=s,r=r,xrange = c(0,1))
winteringArea1D <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
new_winteringArea1D(window,survival,recovery)
}
winteringArea1D(s=s,r=r,xrange = c(0,1))
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & xrange == c(0,0) & yrange == c(0,0)) stop("Please define window or x- and/or y-range"))
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
new_winteringArea(window,survival,recovery)
}
winteringArea(s=s,r=r)
x <- c(0,0)
x== x
identical(x,x)
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))) stop("Please define either window or x- and/or y-range"))
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
new_winteringArea(window,survival,recovery)
}
winteringArea(s=s,r=r)
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
new_winteringArea(window,survival,recovery)
})
}
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
new_winteringArea(window,survival,recovery)
})
}
winteringArea(s=s,r=r)
winteringArea(win,s=s,r=r)
new_winteringArea <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(window, class = "winteringArea")
}
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
new_winteringArea(window,survival,recovery)
})
}
winteringArea(win,s=s,r=r)
w <- winteringArea(win,s=s,r=r)
str(w)
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
return(new_winteringArea(window,survival,recovery))
})
}
w <- winteringArea(win,s=s,r=r)
str(w)
slot(w,"survival")
slot(w,"window")
new_winteringArea <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(list(window,survival, recovery), class = "winteringArea")
}
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
return(new_winteringArea(window,survival,recovery))
})
}
w <- winteringArea(win,s,r)
str(w)
new_winteringArea <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(list(window = window,survival = survival, recovery = recovery), class = "winteringArea")
}
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
return(new_winteringArea(window,survival,recovery))
})
}
str(w)
w <- winteringArea(win,s,r)
str(w)
w <- winteringArea(s=s,r=r,xrange=c(0,1))
str(w)
new_breedingArea <- function(markedInds = numeric(),
winteringArea,
migratoryConnectivity){
stopifnot(markedInds%%1==0)
stopifnot(class(winteringArea) == "winteringArea")
stopifnot(is.function(migratoryConnectivity))
structure(list(markedInds = markedInds, migratoryConnectivity = migratoryConnectivity), class = "breedingArea")
}
new_breedingArea(1000,w,function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)})
new_winteringArea <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(list(window = window,survival = survival, recovery = recovery), class = "winteringArea")
}
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range of wintering area")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
return(new_winteringArea(window,survival,recovery))
})
}
new_breedingArea <- function(markedInds = numeric(),
# winteringArea,
migratoryConnectivity){
stopifnot(markedInds%%1==0)
stopifnot(class(winteringArea) == "winteringArea")
stopifnot(is.function(migratoryConnectivity))
structure(list(markedInds = markedInds, migratoryConnectivity = migratoryConnectivity), class = "breedingArea")
}
new_breedingArea(1000,w,function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)})
breedingArea <- function(markedInds,migratoryConnectivity){
new_breedingArea(markedInds,migratoryConnectivity)
}
new_observationCircumstances <- function(numberOfBreedingAreas = numeric(),
observationTime = numeric(),
breedingAreas = list(),
winteringArea = winteringArea()){
stopifnot(numberOfBreedingAreas%%1==0)
stopifnot(observationTime%%1==0)
stopifnot(is.list(breedingAreas))
stopifnot(class(winteringArea) == "winteringArea")
structure(list(B = numberOfBreedingAreas,
T = observationTime,
breedingAreas = breedingAreas,
winteringArea = winteringArea))
}
new_winteringArea <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(list(window = window,survival = survival, recovery = recovery), class = "winteringArea")
}
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range of wintering area")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
return(new_winteringArea(window,survival,recovery))
})
}
new_breedingArea <- function(markedInds = numeric(),
# winteringArea,
migratoryConnectivity){
stopifnot(markedInds%%1==0)
stopifnot(class(winteringArea) == "winteringArea")
stopifnot(is.function(migratoryConnectivity))
structure(list(markedInds = markedInds, migratoryConnectivity = migratoryConnectivity), class = "breedingArea")
}
breedingArea <- function(markedInds,migratoryConnectivity){
new_breedingArea(markedInds,migratoryConnectivity)
}
new_observationCircumstances <- function(numberOfBreedingAreas = numeric(),
observationTime = numeric(),
breedingAreas = list(),
winteringArea = winteringArea()){
stopifnot(numberOfBreedingAreas%%1==0)
stopifnot(observationTime%%1==0)
stopifnot(is.list(breedingAreas))
stopifnot(class(winteringArea) == "winteringArea")
structure(list(B = numberOfBreedingAreas,
T = observationTime,
breedingAreas = breedingAreas,
winteringArea = winteringArea))
}
observationCircumstances <- function(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea){
new_observationCircumstances(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea)
}
new_markRecaptureSetting <- function(window = NULL, xrange = c(0,0), yrange = c(0,0),
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime
){
numberOfBreedingAreas <- length(markedInds)
winteringArea <- winteringArea(window,survival,recovery,xrange,yrange)
breedingAreas <- list()
for(b in 1:numberOfBreedingAreas){
breedingAreas[[b]] <- breedingArea(markedInds = markedInds[b],migratoryConnectivity)
}
observationCircumstances <- observationCircumstances(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea)
structure(list(winteringArea = winteringArea, breedingAreas = breedingAreas,
observationCircumstances = observationCircumstances), class = "markRecaptureSetting")
}
markRecaptureSetting <- function(boundary,
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime){
new_markRecaptureSetting(boundary,
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime)
}
obj <- markRecaptureSetting(c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, c(1000,500,10),function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},10)
obj$winteringArea
obj <- markRecaptureSetting(xrange = c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, c(1000,500,10),function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},10)
new_markRecaptureSetting <- function(window = NULL, xrange = c(0,0), yrange = c(0,0),
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime
){
numberOfBreedingAreas <- length(markedInds)
winteringArea <- winteringArea(window,survival,recovery,xrange,yrange)
breedingAreas <- list()
for(b in 1:numberOfBreedingAreas){
breedingAreas[[b]] <- breedingArea(markedInds = markedInds[b],migratoryConnectivity)
}
observationCircumstances <- observationCircumstances(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea)
structure(list(winteringArea = winteringArea, breedingAreas = breedingAreas,
observationCircumstances = observationCircumstances), class = "markRecaptureSetting")
}
markRecaptureSetting <- function(window = NULL, xrange = c(0,0), yrange = c(0,0),
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime){
new_markRecaptureSetting(window,xrange,yrange,
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime)
}
obj <- markRecaptureSetting(xrange = c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, c(1000,500,10),function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},10)
#' constructor for wintering area (1 spatial dimension)
#'
#' This function defines the properties of the wintering area.
#' @param w decimal number: spatial point of recovery (1-dimensional)
#' @param t integer: temporal component of recovery
#' @param b integer: breeding area
#' @param s function: survival function defined over whole wintering area, independent of breeding area
#' @param m function: migratory connectivity definded for all breeding areas and over whole wintering area
#' @param r constant: recovery probability, has to be constant over whole wintering area
#' and independent of breeding area
#' @param T integer: length of observation period
#' @return subdensity of recovered individuals for the specified parameters
#' @export
#' @examples f_f_sub()
new_winteringArea <- function(window = owin(),
survival,
recovery){
stopifnot(is.owin(window))
stopifnot(is.function(survival))
stopifnot(is.function(recovery))
structure(list(window = window,survival = survival, recovery = recovery), class = "winteringArea")
}
winteringArea <- function(window=NULL,survival,recovery,xrange = c(0,0),yrange = c(0,0)){
try(if(is.null(window) & identical(xrange, c(0,0)) & identical(yrange, c(0,0))){
stop("Please define either window or x- and/or y-range of wintering area")}else{
if(!is.owin(window)){window <- as.owin(list(xrange = xrange, yrange = yrange))}
return(new_winteringArea(window,survival,recovery))
})
}
new_breedingArea <- function(markedInds = numeric(),
# winteringArea,
migratoryConnectivity){
stopifnot(markedInds%%1==0)
stopifnot(is.function(migratoryConnectivity))
structure(list(markedInds = markedInds, migratoryConnectivity = migratoryConnectivity), class = "breedingArea")
}
breedingArea <- function(markedInds,migratoryConnectivity){
new_breedingArea(markedInds,migratoryConnectivity)
}
new_observationCircumstances <- function(numberOfBreedingAreas = numeric(),
observationTime = numeric(),
breedingAreas = list(),
winteringArea = winteringArea()){
stopifnot(numberOfBreedingAreas%%1==0)
stopifnot(observationTime%%1==0)
stopifnot(is.list(breedingAreas))
stopifnot(class(winteringArea) == "winteringArea")
structure(list(B = numberOfBreedingAreas,
T = observationTime,
breedingAreas = breedingAreas,
winteringArea = winteringArea))
}
observationCircumstances <- function(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea){
new_observationCircumstances(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea)
}
new_markRecaptureSetting <- function(window = NULL, xrange = c(0,0), yrange = c(0,0),
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime
){
numberOfBreedingAreas <- length(markedInds)
winteringArea <- winteringArea(window,survival,recovery,xrange,yrange)
breedingAreas <- list()
for(b in 1:numberOfBreedingAreas){
breedingAreas[[b]] <- breedingArea(markedInds = markedInds[b],migratoryConnectivity)
}
observationCircumstances <- observationCircumstances(numberOfBreedingAreas, observationTime,
breedingAreas,winteringArea)
structure(list(winteringArea = winteringArea, breedingAreas = breedingAreas,
observationCircumstances = observationCircumstances), class = "markRecaptureSetting")
}
markRecaptureSetting <- function(window = NULL, xrange = c(0,0), yrange = c(0,0),
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime){
new_markRecaptureSetting(window,xrange,yrange,
survival,
recovery,
markedInds,
migratoryConnectivity,
observationTime)
}
obj <- markRecaptureSetting(xrange = c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, c(1000,500,10),function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},10)
obj$winteringArea
obj <- markRecaptureSetting(xrange = c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, markedInds = c(1000,500,10),migratoryConnectivity = function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},10)
obj <- markRecaptureSetting(xrange = c(0,1), survival = function(w){0.5*w+.4},
r = function(w){0.01}, markedInds = c(1000,500,10),migratoryConnectivity = function(b,w){dtruncnorm(w,0,1, mean = f_mean[b], sd = f_sd)},
observationTime= 10)
obj$winteringArea
obj$breedingAreas
?purrr::partial
my_list <- purr::partial(list, 1, 2)
my_list("foo")
my_list <- purrr::partial(list, 1, 2)
my_list("foo")
purrr::partial(f, b= 1)
f
f2 <- purrr::partial(f, b= 1)
f2
curve(f)
curve(f, b = 1)
curve(f(1,x), b = 1)
curve(f(1,x))
curve(f(1,x))
curve(f2(x))
log(0)
# Load packages
library(jagsUI)
ss.sim <- function(sigma.proc = 5, sigma.obs = 10, T = 100, n1 = 0){
true <- observed <- numeric()
true[1] <- n1
for (i in 1:(T-1)){
true[i+1] <- rnorm(1, true[i], sigma.proc)
}
for (i in 1:T){
observed[i] <- rnorm(1, true[i], sigma.obs)
}
plot(true, type = "l", ylim = range(c(true, observed)), xlab = "Time", ylab = "x", las = 1)
lines(observed, col = "red")
return(list(observed = observed, true = true))
}
z <- ss.sim(sigma.proc = 7, sigma.obs = 10, T = 50)
# Specify model in BUGS language
sink("ssm.jags")
cat("
model {
# Priors and constraints
x[1] ~ dnorm(0, 0.01)            # Prior for initial population size
sigma1 ~ dunif(0, 100)           # Prior for sd of state process
tau1 <- pow(sigma1, -2)
sigma2 ~ dunif(0, 500)           # Prior for sd of observation process
tau2 <- pow(sigma2, -2)
# Likelihood
# State process
for (t in 1:(T-1)){
x[t+1] ~ dnorm(x[t], tau1)
}
# Observation process
for (t in 1:T) {
y[t] ~ dnorm(x[t], tau2)
}
}
",fill = TRUE)
sink()
# Bundle data
jags.data <- list(y = z$observed, T = length(z$observed))
# Initial values
inits <- function(){list(sigma1 = runif(1, 0, 5))}
# Parameters monitored
parameters <- c("x", "sigma1", "sigma2")
# MCMC settings
ni <- 5000
nt <- 3
nb <- 1000
nc <- 3
# Call JAGS from R (BRT <1 min)
ssm <- jags(jags.data, inits, parameters, "ssm.jags", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel = TRUE)
ssm
str(sim)
str(ssm)
